<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Crossword 2.0</title>
	<meta name="description" content="Crossword">
	<meta name="author" content="electric_g">
	<script type="text/javascript" src="jquery-1.4.2.js"></script>
	<script type="text/javascript" src="jquery.easydrag.handler.beta2.js"></script>
	<style type="text/css" media="screen">
.crossword {
    border: 1px solid #000;
    border-collapse: collapse;
    counter-reset: req;
}
.crossword caption h1 {
    display: inline;
    font-size: 2em;
    margin: 0;
    padding: 0;
}
.crossword caption h2 {
    display: inline;
    font-size: 1em;
    font-style: italic;
    font-weight: normal;
    margin: 0;
    padding: 0;
}
.crossword td {
    background-color: #000;
    border: 1px solid #000;
    height: 30px;
    padding: 6px;
    text-align:left;
    vertical-align:top;
    width: 30px;
}
.crossword td[id].sel, .crossword td[data-hor].sel, .crossword td[data-ver].sel {
    background-color: #FF9;
}
.crossword td[id].err, .crossword td[data-hor].err, .crossword td[data-ver].err {
    background-color: #F00;
}
/*.err:after {
    content: "!";
    color: #000;
    font-size: 10px;
    font-weight: bold;
    margin: 23px -5px 0 0;
    position: absolute;
}*/
.crossword td[id], .crossword td[data-hor], .crossword td[data-ver] {
    background-color: #FFF;
}
.crossword td[id] {
    counter-increment: req;
}
.crossword td[id]:before {
/*    content: attr(id);*/
    content: counter(req);
    font-size: 10px;
    margin: -5px;
    position: absolute;
}
.crossword td input {
    background-color: transparent;
    border: 0 none;
    font-size: 15px;
    height: 100%;
    padding: 0;
    text-align: center;
    text-transform: uppercase;
    width: 100%;
}

#definitions {
    background-color: #CCC;
    float: left;
    width: 400px;
}
#definitions .pointer li {
    cursor: pointer;
}

#tooltip {
    background-color: #0FF;
    border: 2px solid #00F;
    color: #000;
/*    cursor: move;*/
    display:none;
    opacity: 0.7;
    padding: 5px;
    position: absolute;
    width: 200px;
    -moz-border-radius: 15px;
    -webkit-border-radius: 15px;
    border-radius: 15px;
}


#create:after {
    clear: both;
    content: " ";
    display: block;
    font-size: 0;
    height: 0;
    visibility: hidden;
}
#create fieldset {
    float: left;
    margin: 0;
    padding: 0;
}
	</style>
</head>
<body>
<h1>Crossword 2.0</h1>
<h3>Istruzioni</h3>
<p>Frecce della tastiera &larr; &uarr; &rarr; &darr; per muoversi tra le caselle nelle quattro direzioni.<br />
Tasto tab  ⇥ per spostarsi alla definizione successiva.<br />
Tasto dello spazio per cambiare il verso della parola selezionata.<br />
Cliccare su una definizione per spostarsi direttamente sulle celle interessate.<br />
Premere il bottone "check" per controllare con la soluzione.</p>
<input type="button" id="check" value="check" />
<div id="definitions"></div>

<pre>
- cell click:
    - focus sull'input (con le conseguenze dall'azione)
- input click:
    - focus sull'input (con le conseguenze dall'azione)
- definition click:
    - focus sul primo input (con le conseguenze dall'azione)
    - scrollo sulla parola/tooltip
- keypress nell'input:
    - se = [a-zA-Z] scrivo il valore nell'input e focus sull'input
      successivo (nella parola)
    - se = spacebar evidenzio la parola nell'altro verso
    - se altro, disabilito l'azione
- keydown nell'input:
    - se = a una delle frecce sposto il focus sull'input successivo
      (a seconda del verso della freccia)
    - se = tabbar evidenzio la parola successiva (a seconda del verso)
      e focus sul primo input e mostro il tooltip
- input focus:
    - evidenzio la parola
    - mostro il tooltip
    - seleziono tutto il contenuto

TODO
- <del>gestione della selezione della parola e del tooltip quando
  non esiste la parola</del>
- <del>controllare con che ordine avvengono le azioni e se possibile
  non ripeterle inutilmente</del>
- salva/carica partita
- <del>gestione del tasto delete/backspace per cancellare una lettera 
  e/o andare alla casella precedente</del>
- vedere come gestire la tab bar, cioè quale parola selezionare successivamente
- <del>nel tooltip mettere la possibilità di spostarla</del>
- implementare un check della soluzione a parola e non lettera
- dare la possibilità di togliere il rosso degli errori dopo un check
- scrivere istruzioni più decenti :D
- rendere la selezione della tabella possibile anche con la classe
- poter mettere delle caselle con le lettere già inserite (parole crociate facilitate)
- <del>dare una larghezza fissa al tooltip</del>
</pre>

<script type="text/javascript">//<![CDATA[

(function($) {
// plugin definition
$.fn.crossword = function(options) {
    var defaults = {
        cross_class     : "crossword",
        td_sel          : "sel",
        hor_id          : "hor",
        ver_id          : "ver",
        tooltip_id      : "tooltip",
        prefix_id       : "d",
        pointer         : "pointer",
        tooltip_top     : -40,
        tooltip_left    : 40
    };
    // system variables
    var _hor = "hor",
        _ver = "ver",
        _key_l = 37, // left
        _key_u = 38, // up
        _key_r = 39, // right
        _key_d = 40, // down
        _key_tab = 9, // tab
        _key_bks = 8, // backspace
        _key_del = 46, // delete
        _rspace = /\s+/,
        D = "#",
        version = "2.0";
    // extend default options with those provided
    var opts = $.extend(defaults, options);

    // implementation code goes here.    
    return this.each(function(){

        var $html = $("html"),
            $body = $("body"),
            $table = $(this),
            $tbody = $table.find("tbody"),
            $defs = $(D + opts.hor_id + "," + D +  opts.ver_id),
            $tooltip = $("<div id='" + opts.tooltip_id + "'></div>"),
            _$input = $tbody.find("input"),
            _$td = $tbody.find("td"),
            _dir = _hor,
            _change_dir = false;

        $table.addClass(opts.cross_class);
        $defs.addClass(opts.pointer);
        $table.after($tooltip);
        $tooltip.easydrag();


        function selectWord(number, dir, $td) {
            var $word;
            _$td.removeClass(opts.td_sel);
            if (dir != _hor && dir != _ver)
                return false;
            $word = _$td.filter("td[data-" + dir + "='" + opts.prefix_id + number + "'], td[id='" + opts.prefix_id + number + "']");
            _dir = dir;
            // se in questa direzione non c'è una parola
            if ($word.length <= 1) {
                // evidenzio la cella in cui sono
                $td.addClass(opts.td_sel);
                // ritorno un oggetto (o cella) vuoto
                return $();
            }
            $word.addClass(opts.td_sel);
            $first = $word.eq(0);
            return $first;
        }


        function tooltip(number, dir, position) {
            if (position === null) {
                $tooltip.css("display", "");
                return false;
            }
            id = (dir == _hor) ? opts.hor_id : opts.ver_id;
            $def = $defs.filter("[id='" + id + "']").find("[data-def='" + number + "']");
            $tooltip.html($def.html());
            var left = position.left + opts.tooltip_left,
                top = position.top + opts.tooltip_top;
            // impedisco che finisca fuori dalla finestra
            if (left < 0)
                left = 0;
            if (top < 0)
                top = 0;
            if (left > ($html.outerWidth() - $tooltip.outerWidth()))
                left = $html.outerWidth() - $tooltip.outerWidth();
            if (top > ($html.outerHeight() - $tooltip.outerHeight()))
                top = $html.outerHeight() - $tooltip.outerHeight();
            $tooltip.css("left", left);
            $tooltip.css("top", top);
            $tooltip.css("display", "block");
        }


        // animated automatic scroll to the tooltip
        function scrollTo() {
            var t_top = $tooltip.offset().top,
                t_left = $tooltip.offset().left,
            // the element most top/left between first and tooltip
                off_top = (t_top < first_pos.top) ? t_top : first_pos.top,
                off_left = (t_left < first_pos.left) ? t_left : first_pos.top;
            $html.animate({scrollTop: off_top + "px"}); // IE, FF
            $body.animate({scrollTop: off_top + "px"}); // chrome, safari
            $html.animate({scrollLeft: off_left + "px"}); // IE, FF
            $body.animate({scrollLeft: off_left + "px"}); // chrome, safari
            // Opera scrolls already before because of the focus, so this is a duplicate with a strange effect
        }


        // input focus
        _$input.bind("click focus", function(event, dir) {
            // console.log(event.target+" "+event.type);
            // unisco i due eventi per evitare duplicati
            // e se è un click lo disabilito, disabilitando anche gli altri click sulla tabella
            if (event.type == "click") {
                return false;
            }
            var $input = $(this),
                $td = $input.closest("td"),
                dir = (dir || _dir),
                id = $td.attr("data-" + dir);
            if (!id)
                id = $td.attr("id");
            number = id.replace(opts.prefix_id, "");
            // seleziono il contenuto
            $input.select();
            // evidenzio la parola
            $first = selectWord(number, dir, $td);
            // mostro il tooltip
            first_pos = $first.position()
            tooltip(number, dir, first_pos);
            // mantenere la posizione relativa alla prima lettera fatta col drag&drop
            $tooltip.ondrop(function() {
                var pos = $tooltip.position();
                opts.tooltip_left = pos.left - first_pos.left;
                opts.tooltip_top = pos.top - first_pos.top;
            });
        });


        // definitions click
        $defs.bind("click", function(event) {
            // console.log(event.target+" "+event.type);
            var el = event.target,
                $elem = $(el),
                $ul = $(this),
                $li,
                dir, number,
                position;
            if (el.nodeName === "UL")
                return false;
            else if (el.nodeName === "LI")
                $li = $elem;
            else
                $li = $elem.closest("li");
            dir = ($ul.attr("id") == opts.hor_id) ? _hor : _ver;
            number = parseInt($li.attr("data-def"));
            // focus sulla prima lettera
            $(D + opts.prefix_id + number).find("input").trigger("focus", [dir]);
            // scroll sulla parola/tooltip
            scrollTo();
        });


        // cell click
        $tbody.bind("click", function(event) {
            // console.log(event.target+" "+event.type);
            var el = event.target,
                $elem = $(el);
            if (el.nodeName === "TD") {
                var $input = $elem.find("input");
                if ($input.length) {
                    $input.trigger("focus");
                }
            }
        });


        // input blur
        _$input.bind("blur", function() {
            _$td.removeClass(opts.td_sel);
            $tooltip.css("display", "");
        });


        // for chrome and safari click event
        _$input.live("mouseup", function() {
            return false;
        });


        // input keydown
        _$input.bind("keydown", function(event) {
            // console.log(event.target+" "+event.type);
            var key = event.which;
            // exit from this event if not one of the keys
            if ($.inArray(key, [_key_u, _key_r, _key_d, _key_l,
                            _key_tab, _key_bks, _key_del]) == -1) {
                return true;
            }
            var $input = $(this),
                $td = $input.closest("td"),
                $tr = $input.closest("tr"),
                $next,
                $tbody_child = $tbody.children("tr"),
                $tr_child = $tr.children(),
                new_tr_i = $tbody_child.index($tr),
                new_td_i = $tr_child.index($td),
                last_tr = $tbody_child.length,
                last_td = $tr_child.length;
            do {
                // order of new_tr_i and new_td_i allocations is important
                switch (key) {
                    // ↑ up
                    case _key_u:
                        new_tr_i = modMinus(new_tr_i, 1, last_tr);
                        new_td_i = modMinus(new_td_i, parseInt(new_tr_i / (last_tr-1)), last_td);
                        break;
                    // → right
                    case _key_r:
                        new_tr_i = modPlus(new_tr_i, parseInt(new_td_i / (last_td-1)), last_tr);
                        new_td_i = modPlus(new_td_i, 1, last_td);
                        break;
                    // ↓ down
                    case _key_d:
                        new_td_i = modPlus(new_td_i, parseInt(new_tr_i / (last_tr-1)), last_td);
                        new_tr_i = modPlus(new_tr_i, 1, last_tr);
                        break;
                    // ← left
                    case _key_l:
                        new_td_i = modMinus(new_td_i, 1, last_td);
                        new_tr_i = modMinus(new_tr_i, parseInt(new_td_i / (last_td-1)), last_tr);
                        break;
                    // ⇥ tab bar
                    case _key_tab:
                        // la prossima cella con id ma senza data-[_dir]
                        var last = ":last-child";
                        if (_dir == _hor)
                            $firsts = _$td.filter("[id]").not("[data-" + _dir + "]").not(last);
                        else
                            $firsts = $tbody_child.not(last).find("[id]").not("[data-" + _dir + "]");
                        $firsts = $firsts.add($td);
                        var i = $firsts.index($td) + 1;
                        if (i >= $firsts.length)
                            i = 0;
                        $firsts.eq(i).find("input").trigger("focus");
                        return false;
                        break;
                    // backspace
                    case _key_bks:
                        if ($input.val()) {
                            // cancello il suo valore
                            $input.val("");
                        }
                        else {
                            // mi sposto indietro
                            var $word = _$td.filter(".sel"),
                                i = $word.index($td) - 1;
                            // per non tornare alla fine della parola
                            if (i < 0)
                                i = 0;
                            $word.eq(i).find("input").trigger("focus");
                        }
                        return false;
                        break;
                    // delete
                    case _key_del:
                        $input.val("");
                        return false;
                        break;
                    default:
                        return true;
                        break;
                }
                $next = $tbody_child.eq(new_tr_i).children("td" ).eq(new_td_i).find("input");
            } while ($next.length == 0);
            $next.trigger("focus");
        });


        // input keypress
        _$input.bind("keypress", function(event) {
            // console.log(event.target+" "+event.type);
            var key = event.which;
            // exit from this event if not one of the keys
            if (!(key >= 65 && key <= 90) &&
                !(key >=97 && key <= 122) &&
                !(key == 32)) {
                return false;
            }
            var $input = $(this);
            // a-zA-Z
            if ((key >= 65 && key <= 90) || (key >=97 && key <= 122)) {
                var $td = $input.closest("td"),
                    $word = _$td.filter(".sel"),
                    i = $word.index($td) + 1;
                $input.val(String.fromCharCode(key));
                $word.eq(i).find("input").trigger("focus");
                event.preventDefault(); // because Opera would write the char also in the next input
            }
            // space
            else if (key == 32) {
                event.preventDefault();
                _dir = (_dir == _hor) ? _ver : _hor;
                $input.trigger("focus");
            }
            // else {
            //     return false;
            // }
        });


    });
};
// end plugin definition



// plugin definition
$.fn.crosswordCreate = function(options) {
    var defaults = {
        crossword_id        : "crossword",
        definitions_id      : "definitions",
        hor_id              : "hor",
        ver_id              : "ver",
        bb                  : "#", // blackblock, NOT the id simbol !!
        crossword_val       : "",
        hor_val             : "",
        ver_val             : "",
        prefix_id           : "d",
        hor_title           : "Orizzontali",
        ver_title           : "Verticali"
    };
    // system variables
    var _hor = "hor",
        _ver = "ver",
        _rspace = /\s+/,
        _rreturn = /[\r\n]/g,
        _rsspace = /[ \t]+/g,
        D = "#",
        version = "2.0";
    // extend default options with those provided
    var opts = $.extend(defaults, options);
    
    // Our plugin implementation code goes here.
    
    // schema
    var hor = [], ver = [],
        c = 0,
        letters,
        schema = "<table id='" + opts.crossword_id + "'><caption><h1>Schema n° 12345</h1> <h2><a href='http://it.linkedin.com/in/fabriziocalderan'>Fabrizio Calderan</a></h2></caption><tbody>",
        rows = $.trim(opts.crossword_val).split(_rspace),
        rows_l = rows.length,
        cols_l = rows[0].length;
    for (h=0; h<cols_l; h++)
        ver[h] = 0; // posso scrivere
    $.each(rows, function(h, row) {
        if (typeof row === "string" && row != "") {
            hor[h] = 0; // posso scrivere
            schema += "<tr>";
            letters = row.split("");
            $.each(letters, function(v, letter) {
                if (letter == opts.bb) {
                    ver[v] = hor[h] = 0;
                    schema += "<td></td>";
                }
                else {
                    schema += "<td";
                    if (ver[v] || hor[h]) {
                        data1 = hor[h] ? ("data-"+_hor+"='"+opts.prefix_id+hor[h]+"'") : "";
                        data2 = ver[v] ? ("data-"+_ver+"='"+opts.prefix_id+ver[v]+"'") : "";
                        schema += " " + (data1 + " " + data2).trim();
                    }
                    // posso scrivere && non sono sul bordo && non e' una parola di una sola lettera
                    if ((!hor[h] && (v+1)<cols_l && rows[h][v+1]!=opts.bb) ||
                        (!ver[v] && (h+1)<rows_l && rows[h+1][v]!=opts.bb)) {
                        schema += " id='" + opts.prefix_id + (++c) + "'";
                        hor[h] = hor[h] || c;
                        ver[v] = ver[v] || c;
                    }
                    schema += "><input type='text' maxlength='1' value='' /></td>";
                }
            });
            schema += "</tr>";
        }
    });
    schema += "</tbody></table>";

    // definitions
    var strings = [opts.hor_val, opts.ver_val],
        ids = [opts.hor_id, opts.ver_id],
        titles = [opts.hor_title, opts.ver_title],
        number = 0,
        defs = [];
    $.each(strings, function(i, val) {
        rows = val.trim().replace(_rsspace, " ").split(_rreturn);
        defs[i] = "<h3>" + titles[i] + "</h3><ul id='" + ids[i] + "'>";
        $.each(rows, function(k, row) {
            row = row.trim();
            if (row != "") {
                number = parseInt(row);
                defs[i] += "<li data-def='" + number + "'><span>" + number + "</span> " + row.replace(number, "").trim() + "</li>";
            }
        });
        defs[i] += "</ul>";
    });

    $(D + opts.definitions_id).append(defs.join("")).before(schema);

    return this;
};
// end plugin definition



// plugin definition
$.fn.crosswordCheck = function(options) {
    var defaults = {
        crossword_id        : "crossword",
        solution        : "",
        td_err              : "err",
        bb                  : "#", // blackblock, NOT the id simbol !!
        crossword_val       : "",
        hor_val             : "",
    };
    // system variables
    var _rspace = /\s+/,
        _rreturn = /[\r\n]/g,
        D = "#",
        version = "1.0";
    // extend default options with those provided
    var opts = $.extend(defaults, options);

    // Our plugin implementation code goes here.
    var solution = $.trim(opts.solution).replace(_rspace, "").replace(_rreturn, "").toUpperCase(),
        griglia = "",
        $cell = $(D + opts.crossword_id + " td");
    $.each($cell, function() {
        griglia += $(this).find("input").val() || opts.bb;
    });
    griglia = griglia.toUpperCase();
    $cell.removeClass(opts.td_err);
    $.each(solution.split(""), function(i, letter) {
        if (letter != griglia[i])
            $cell.eq(i).addClass(opts.td_err);
    });
    return this;
};
// end plugin definition



// http://users.wpi.edu/~martin/mod.html
function mod(a, b) {
    if (b <= 0)
        return(-1);
    else
        return( ((a % b) + b) % b );
}
function modPlus(a, b, m) { // Add a and b modulo m
    return( mod( (a % m) + (b % m), m) );
}
function modMinus(a, b, m) { // Subtract b from a modulo m
    return( mod( (a % m) - (b % m), m) );
}


})(jQuery);

$.get("cruciverba-2.0.source.php", function(response) { 

    $resp = $(response);
    var cw = $resp.find("#create_crossword").val(),
        hor = $resp.find("#create_hor").val(),
        ver = $resp.find("#create_ver").val(),
        cw_id = "crossword12345";

    $.fn.crosswordCreate({
        crossword_id: cw_id,
        crossword_val: cw,
        hor_val: hor,
        ver_val: ver
    });

    $("#"+cw_id).crossword();

    $("#check").click(function() {
        $.fn.crosswordCheck({
            solution: cw,
            crossword_id: cw_id
        });
    });

});
//]]></script>
</body>
</html>